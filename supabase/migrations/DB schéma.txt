DB schÃ©ma :
-- WARNING: This schema is for context only and is not meant to be run.
-- Table order and constraints may not be valid for execution.

CREATE TABLE public.albums (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  couple_id uuid NOT NULL,
  title text NOT NULL,
  description text,
  is_private boolean DEFAULT false,
  cover_photo_url text,
  created_at timestamp with time zone DEFAULT now(),
  created_by uuid,
  CONSTRAINT albums_pkey PRIMARY KEY (id),
  CONSTRAINT albums_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id),
  CONSTRAINT albums_couple_id_fkey FOREIGN KEY (couple_id) REFERENCES public.couples(id)
);
CREATE TABLE public.bucket_items (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  bucket_id uuid NOT NULL,
  content text NOT NULL,
  is_completed boolean DEFAULT false,
  created_by uuid NOT NULL,
  CONSTRAINT bucket_items_pkey PRIMARY KEY (id),
  CONSTRAINT bucket_items_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES public.buckets(id),
  CONSTRAINT bucket_items_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id)
);
CREATE TABLE public.buckets (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  title text NOT NULL,
  description text,
  couple_id uuid NOT NULL,
  created_by uuid NOT NULL,
  icon text,
  color text,
  CONSTRAINT buckets_pkey PRIMARY KEY (id),
  CONSTRAINT buckets_couple_id_fkey FOREIGN KEY (couple_id) REFERENCES public.couples(id),
  CONSTRAINT buckets_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id)
);
CREATE TABLE public.couple_events (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  couple_id uuid NOT NULL,
  author_id uuid NOT NULL,
  title text NOT NULL CHECK (length(TRIM(BOTH FROM title)) > 0),
  starts_at timestamp with time zone NOT NULL,
  ends_at timestamp with time zone,
  notes text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  all_day boolean NOT NULL DEFAULT false,
  CONSTRAINT couple_events_pkey PRIMARY KEY (id),
  CONSTRAINT couple_events_couple_id_fkey FOREIGN KEY (couple_id) REFERENCES public.couples(id),
  CONSTRAINT couple_events_author_id_fkey FOREIGN KEY (author_id) REFERENCES auth.users(id)
);
CREATE TABLE public.couple_members (
  user_id uuid NOT NULL,
  couple_id uuid NOT NULL,
  role text DEFAULT 'partner'::text,
  joined_at timestamp with time zone DEFAULT now(),
  CONSTRAINT couple_members_pkey PRIMARY KEY (user_id),
  CONSTRAINT couple_members_couple_id_fkey FOREIGN KEY (couple_id) REFERENCES public.couples(id),
  CONSTRAINT couple_members_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.couples (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  join_code text NOT NULL UNIQUE,
  started_at date NOT NULL,
  created_by uuid NOT NULL,
  created_at timestamp with time zone DEFAULT now(),
  CONSTRAINT couples_pkey PRIMARY KEY (id),
  CONSTRAINT couples_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id)
);
CREATE TABLE public.love_notes (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  couple_id uuid NOT NULL,
  author_id uuid NOT NULL,
  content text NOT NULL CHECK (length(TRIM(BOTH FROM content)) > 0),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT love_notes_pkey PRIMARY KEY (id),
  CONSTRAINT love_notes_couple_id_fkey FOREIGN KEY (couple_id) REFERENCES public.couples(id),
  CONSTRAINT love_notes_author_id_fkey FOREIGN KEY (author_id) REFERENCES auth.users(id)
);
CREATE TABLE public.note_reactions (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  note_id uuid NOT NULL,
  user_id uuid NOT NULL,
  emoji text NOT NULL CHECK (emoji = ANY (ARRAY['â¤ï¸'::text, 'ðŸ˜†'::text, 'ðŸ¥²'::text])),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT note_reactions_pkey PRIMARY KEY (id),
  CONSTRAINT note_reactions_note_id_fkey FOREIGN KEY (note_id) REFERENCES public.love_notes(id),
  CONSTRAINT note_reactions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);
CREATE TABLE public.photos (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  album_id uuid NOT NULL,
  couple_id uuid NOT NULL,
  url text NOT NULL,
  thumbnail_url text,
  caption text,
  latitude numeric,
  longitude numeric,
  location_name text,
  taken_at timestamp with time zone,
  uploaded_by uuid NOT NULL,
  created_at timestamp with time zone DEFAULT now(),
  CONSTRAINT photos_pkey PRIMARY KEY (id),
  CONSTRAINT photos_uploaded_by_fkey FOREIGN KEY (uploaded_by) REFERENCES auth.users(id),
  CONSTRAINT photos_album_id_fkey FOREIGN KEY (album_id) REFERENCES public.albums(id),
  CONSTRAINT photos_couple_id_fkey FOREIGN KEY (couple_id) REFERENCES public.couples(id)
);
CREATE TABLE public.profiles (
  id uuid NOT NULL,
  display_name text,
  created_at timestamp with time zone DEFAULT now(),
  first_name text,
  avatar_url text,
  CONSTRAINT profiles_pkey PRIMARY KEY (id),
  CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id)
);
CREATE TABLE public.user_prefs (
  user_id uuid NOT NULL,
  notes_enabled boolean NOT NULL DEFAULT true,
  events_enabled boolean NOT NULL DEFAULT true,
  do_not_disturb jsonb NOT NULL DEFAULT '{"end": "07:00", "start": "22:00"}'::jsonb,
  notify_notes boolean DEFAULT true,
  notify_calendar boolean DEFAULT true,
  notify_gallery boolean DEFAULT true,
  CONSTRAINT user_prefs_pkey PRIMARY KEY (user_id),
  CONSTRAINT user_prefs_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);











policies :
[
  {
    "policies_json": [
      {
        "policy_name": "Couples can view their albums",
        "table_schema": "public",
        "table_name": "albums",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(couple_id IN ( SELECT couple_members.couple_id\n   FROM couple_members\n  WHERE couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "Couples can create albums",
        "table_schema": "public",
        "table_name": "albums",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "(couple_id IN ( SELECT couple_members.couple_id\n   FROM couple_members\n  WHERE couple_members.user_id = auth.uid()))"
      },
      {
        "policy_name": "Couples can update their albums",
        "table_schema": "public",
        "table_name": "albums",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "(couple_id IN ( SELECT couple_members.couple_id\n   FROM couple_members\n  WHERE couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "prefs: insert self",
        "table_schema": "public",
        "table_name": "user_prefs",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "user_id = auth.uid()"
      },
      {
        "policy_name": "prefs: update self",
        "table_schema": "public",
        "table_name": "user_prefs",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "user_id = auth.uid()",
        "check_expression": "user_id = auth.uid()"
      },
      {
        "policy_name": "couples: update by member",
        "table_schema": "public",
        "table_name": "couples",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = couples.id AND cm.user_id = auth.uid()))",
        "check_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = couples.id AND cm.user_id = auth.uid()))"
      },
      {
        "policy_name": "Couples can delete their albums",
        "table_schema": "public",
        "table_name": "albums",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "(couple_id IN ( SELECT couple_members.couple_id\n   FROM couple_members\n  WHERE couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "Couples can view their photos",
        "table_schema": "public",
        "table_name": "photos",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(couple_id IN ( SELECT couple_members.couple_id\n   FROM couple_members\n  WHERE couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "Couples can upload photos",
        "table_schema": "public",
        "table_name": "photos",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "(couple_id IN ( SELECT couple_members.couple_id\n   FROM couple_members\n  WHERE couple_members.user_id = auth.uid()))"
      },
      {
        "policy_name": "Couples can update their photos",
        "table_schema": "public",
        "table_name": "photos",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "(couple_id IN ( SELECT couple_members.couple_id\n   FROM couple_members\n  WHERE couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "Couples can delete their photos",
        "table_schema": "public",
        "table_name": "photos",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "(couple_id IN ( SELECT couple_members.couple_id\n   FROM couple_members\n  WHERE couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "Users can view buckets of their couple",
        "table_schema": "public",
        "table_name": "buckets",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(auth.uid() IN ( SELECT couple_members.user_id\n   FROM couple_members\n  WHERE couple_members.couple_id = buckets.couple_id))",
        "check_expression": null
      },
      {
        "policy_name": "Users can insert buckets for their couple",
        "table_schema": "public",
        "table_name": "buckets",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "(auth.uid() IN ( SELECT couple_members.user_id\n   FROM couple_members\n  WHERE couple_members.couple_id = buckets.couple_id))"
      },
      {
        "policy_name": "Users can update buckets of their couple",
        "table_schema": "public",
        "table_name": "buckets",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "(auth.uid() IN ( SELECT couple_members.user_id\n   FROM couple_members\n  WHERE couple_members.couple_id = buckets.couple_id))",
        "check_expression": null
      },
      {
        "policy_name": "Users can delete buckets of their couple",
        "table_schema": "public",
        "table_name": "buckets",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "(auth.uid() IN ( SELECT couple_members.user_id\n   FROM couple_members\n  WHERE couple_members.couple_id = buckets.couple_id))",
        "check_expression": null
      },
      {
        "policy_name": "Users can view items of their couple's buckets",
        "table_schema": "public",
        "table_name": "bucket_items",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM buckets\n     JOIN couple_members ON buckets.couple_id = couple_members.couple_id\n  WHERE buckets.id = bucket_items.bucket_id AND couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "Users can insert items to their couple's buckets",
        "table_schema": "public",
        "table_name": "bucket_items",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "(EXISTS ( SELECT 1\n   FROM buckets\n     JOIN couple_members ON buckets.couple_id = couple_members.couple_id\n  WHERE buckets.id = bucket_items.bucket_id AND couple_members.user_id = auth.uid()))"
      },
      {
        "policy_name": "profiles: read self",
        "table_schema": "public",
        "table_name": "profiles",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "id = auth.uid()",
        "check_expression": null
      },
      {
        "policy_name": "profiles: upsert self",
        "table_schema": "public",
        "table_name": "profiles",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "id = auth.uid()"
      },
      {
        "policy_name": "profiles: update self",
        "table_schema": "public",
        "table_name": "profiles",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "id = auth.uid()",
        "check_expression": null
      },
      {
        "policy_name": "couples: read if member",
        "table_schema": "public",
        "table_name": "couples",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = couples.id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "members: read own membership",
        "table_schema": "public",
        "table_name": "couple_members",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "user_id = auth.uid()",
        "check_expression": null
      },
      {
        "policy_name": "notes: select if same couple",
        "table_schema": "public",
        "table_name": "love_notes",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = love_notes.couple_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "Users can update items of their couple's buckets",
        "table_schema": "public",
        "table_name": "bucket_items",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM buckets\n     JOIN couple_members ON buckets.couple_id = couple_members.couple_id\n  WHERE buckets.id = bucket_items.bucket_id AND couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "notes: delete by couple member",
        "table_schema": "public",
        "table_name": "love_notes",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = love_notes.couple_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "Users can delete items of their couple's buckets",
        "table_schema": "public",
        "table_name": "bucket_items",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM buckets\n     JOIN couple_members ON buckets.couple_id = couple_members.couple_id\n  WHERE buckets.id = bucket_items.bucket_id AND couple_members.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "profiles: select own",
        "table_schema": "public",
        "table_name": "profiles",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "id = auth.uid()",
        "check_expression": null
      },
      {
        "policy_name": "profiles: update own",
        "table_schema": "public",
        "table_name": "profiles",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "id = auth.uid()",
        "check_expression": null
      },
      {
        "policy_name": "profiles: select same couple",
        "table_schema": "public",
        "table_name": "profiles",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm1\n     JOIN couple_members cm2 ON cm1.couple_id = cm2.couple_id\n  WHERE cm1.user_id = auth.uid() AND cm2.user_id = profiles.id))",
        "check_expression": null
      },
      {
        "policy_name": "events: select in couple",
        "table_schema": "public",
        "table_name": "couple_events",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = couple_events.couple_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "events: insert by member",
        "table_schema": "public",
        "table_name": "couple_events",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = couple_events.couple_id AND cm.user_id = auth.uid())) AND author_id = auth.uid()"
      },
      {
        "policy_name": "events: update by member",
        "table_schema": "public",
        "table_name": "couple_events",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = couple_events.couple_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "events: delete by member",
        "table_schema": "public",
        "table_name": "couple_events",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = couple_events.couple_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "reactions: select in couple",
        "table_schema": "public",
        "table_name": "note_reactions",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM love_notes ln\n     JOIN couple_members cm ON cm.couple_id = ln.couple_id\n  WHERE ln.id = note_reactions.note_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "reactions: insert own in couple",
        "table_schema": "public",
        "table_name": "note_reactions",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "user_id = auth.uid() AND (EXISTS ( SELECT 1\n   FROM love_notes ln\n     JOIN couple_members cm ON cm.couple_id = ln.couple_id\n  WHERE ln.id = note_reactions.note_id AND cm.user_id = auth.uid()))"
      },
      {
        "policy_name": "reactions: delete own in couple",
        "table_schema": "public",
        "table_name": "note_reactions",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "user_id = auth.uid() AND (EXISTS ( SELECT 1\n   FROM love_notes ln\n     JOIN couple_members cm ON cm.couple_id = ln.couple_id\n  WHERE ln.id = note_reactions.note_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "notes: update by couple member",
        "table_schema": "public",
        "table_name": "love_notes",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = love_notes.couple_id AND cm.user_id = auth.uid()))",
        "check_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = love_notes.couple_id AND cm.user_id = auth.uid()))"
      },
      {
        "policy_name": "prefs: select self",
        "table_schema": "public",
        "table_name": "user_prefs",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "user_id = auth.uid()",
        "check_expression": null
      },
      {
        "policy_name": "notes: select by couple member",
        "table_schema": "public",
        "table_name": "love_notes",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = love_notes.couple_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "notes: insert by couple member",
        "table_schema": "public",
        "table_name": "love_notes",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "(EXISTS ( SELECT 1\n   FROM couple_members cm\n  WHERE cm.couple_id = love_notes.couple_id AND cm.user_id = auth.uid()))"
      },
      {
        "policy_name": "notes: delete by author",
        "table_schema": "public",
        "table_name": "love_notes",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "author_id = auth.uid()",
        "check_expression": null
      },
      {
        "policy_name": "reactions: select by couple member",
        "table_schema": "public",
        "table_name": "note_reactions",
        "command": "SELECT",
        "permissive": true,
        "roles": [],
        "using_expression": "(EXISTS ( SELECT 1\n   FROM love_notes n\n     JOIN couple_members cm ON cm.couple_id = n.couple_id\n  WHERE n.id = note_reactions.note_id AND cm.user_id = auth.uid()))",
        "check_expression": null
      },
      {
        "policy_name": "reactions: insert by couple member",
        "table_schema": "public",
        "table_name": "note_reactions",
        "command": "INSERT",
        "permissive": true,
        "roles": [],
        "using_expression": null,
        "check_expression": "(EXISTS ( SELECT 1\n   FROM love_notes n\n     JOIN couple_members cm ON cm.couple_id = n.couple_id\n  WHERE n.id = note_reactions.note_id AND cm.user_id = auth.uid()))"
      },
      {
        "policy_name": "reactions: update self",
        "table_schema": "public",
        "table_name": "note_reactions",
        "command": "UPDATE",
        "permissive": true,
        "roles": [],
        "using_expression": "user_id = auth.uid()",
        "check_expression": "user_id = auth.uid()"
      },
      {
        "policy_name": "reactions: delete self",
        "table_schema": "public",
        "table_name": "note_reactions",
        "command": "DELETE",
        "permissive": true,
        "roles": [],
        "using_expression": "user_id = auth.uid()",
        "check_expression": null
      }
    ]
  }
]











Functions :
[
  {
    "functions_json": [
      {
        "function_name": "ensure_max_two_members",
        "schema_name": "public",
        "definition": "CREATE OR REPLACE FUNCTION public.ensure_max_two_members()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  member_count int;\r\nbegin\r\n  select count(*) into member_count\r\n  from public.couple_members\r\n  where couple_id = new.couple_id;\r\n\r\n  if member_count >= 2 then\r\n    raise exception 'Ce couple a dÃ©jÃ  2 membres.';\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
      },
      {
        "function_name": "uid",
        "schema_name": "auth",
        "definition": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n"
      },
      {
        "function_name": "role",
        "schema_name": "auth",
        "definition": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
      },
      {
        "function_name": "email",
        "schema_name": "auth",
        "definition": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
      },
      {
        "function_name": "get_prefixes",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE STRICT\nAS $function$\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n$function$\n"
      },
      {
        "function_name": "add_prefixes",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    prefixes text[];\nBEGIN\n    prefixes := \"storage\".\"get_prefixes\"(\"_name\");\n\n    IF array_length(prefixes, 1) > 0 THEN\n        INSERT INTO storage.prefixes (name, bucket_id)\n        SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;\n    END IF;\nEND;\n$function$\n"
      },
      {
        "function_name": "delete_prefix",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if we can delete the prefix\n    IF EXISTS(\n        SELECT FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    )\n    OR EXISTS(\n        SELECT FROM \"storage\".\"objects\"\n        WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"\n          AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    ) THEN\n    -- There are sub-objects, skip deletion\n    RETURN false;\n    ELSE\n        DELETE FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\")\n          AND \"prefixes\".\"name\" = \"_name\";\n        RETURN true;\n    END IF;\nEND;\n$function$\n"
      },
      {
        "function_name": "prefixes_insert_trigger",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    RETURN NEW;\nEND;\n$function$\n"
      },
      {
        "function_name": "is_member_of_couple",
        "schema_name": "public",
        "definition": "CREATE OR REPLACE FUNCTION public.is_member_of_couple(_couple_id uuid)\n RETURNS boolean\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\n  select exists (\r\n    select 1\r\n    from public.couple_members\r\n    where couple_id = _couple_id\r\n      and user_id   = auth.uid()\r\n  );\r\n$function$\n"
      },
      {
        "function_name": "handle_new_user",
        "schema_name": "public",
        "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nbegin\r\n  insert into public.profiles (id, created_at, display_name)\r\n  values (new.id, now(), split_part(new.email, '@', 1))\r\n  on conflict (id) do nothing;\r\n  return new;\r\nend;\r\n$function$\n"
      },
      {
        "function_name": "jwt",
        "schema_name": "auth",
        "definition": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
      },
      {
        "function_name": "filename",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
      },
      {
        "function_name": "operation",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
      },
      {
        "function_name": "get_level",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.get_level(name text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n$function$\n"
      },
      {
        "function_name": "get_prefix",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n$function$\n"
      },
      {
        "function_name": "objects_insert_prefix_trigger",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    NEW.level := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
      },
      {
        "function_name": "foldername",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\nBEGIN\n    -- Split on \"/\" to get path segments\n    SELECT string_to_array(name, '/') INTO _parts;\n    -- Return everything except the last segment\n    RETURN _parts[1 : array_length(_parts,1) - 1];\nEND\n$function$\n"
      },
      {
        "function_name": "extension",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\n    _filename text;\nBEGIN\n    SELECT string_to_array(name, '/') INTO _parts;\n    SELECT _parts[array_length(_parts,1)] INTO _filename;\n    RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
      },
      {
        "function_name": "update_updated_at_column",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
      },
      {
        "function_name": "can_insert_object",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
      },
      {
        "function_name": "list_objects_with_delimiter",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n"
      },
      {
        "function_name": "list_multipart_uploads_with_delimiter",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
      },
      {
        "function_name": "create_couple",
        "schema_name": "public",
        "definition": "CREATE OR REPLACE FUNCTION public.create_couple(p_started_at date)\n RETURNS TABLE(couple_id uuid, join_code text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  uid uuid := auth.uid();\r\n  new_cpl uuid;\r\n  code text;\r\nbegin\r\n  if uid is null then\r\n    raise exception 'Non authentifiÃ©';\r\n  end if;\r\n\r\n  if exists (select 1 from public.couple_members cm where cm.user_id = uid) then\r\n    raise exception 'DÃ©jÃ  dans un couple';\r\n  end if;\r\n\r\n  code := upper(substr(md5(gen_random_uuid()::text), 1, 6));\r\n\r\n  insert into public.couples(id, join_code, started_at, created_by)\r\n  values (gen_random_uuid(), code, p_started_at, uid)\r\n  returning id into new_cpl;\r\n\r\n  insert into public.couple_members(user_id, couple_id)\r\n  values (uid, new_cpl);\r\n\r\n  return query select new_cpl as couple_id, code as join_code;\r\nend;\r\n$function$\n"
      },
      {
        "function_name": "delete_prefix_hierarchy_trigger",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    prefix text;\nBEGIN\n    prefix := \"storage\".\"get_prefix\"(OLD.\"name\");\n\n    IF coalesce(prefix, '') != '' THEN\n        PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);\n    END IF;\n\n    RETURN OLD;\nEND;\n$function$\n"
      },
      {
        "function_name": "join_couple",
        "schema_name": "public",
        "definition": "CREATE OR REPLACE FUNCTION public.join_couple(p_join_code text)\n RETURNS TABLE(couple_id uuid)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  uid uuid := auth.uid();\r\n  target uuid;\r\n  members int;\r\nbegin\r\n  if uid is null then\r\n    raise exception 'Non authentifiÃ©';\r\n  end if;\r\n\r\n  if exists (select 1 from public.couple_members cm where cm.user_id = uid) then\r\n    raise exception 'DÃ©jÃ  dans un couple';\r\n  end if;\r\n\r\n  select c.id into target\r\n  from public.couples c\r\n  where c.join_code = upper(p_join_code);\r\n\r\n  if target is null then\r\n    raise exception 'Code invalide';\r\n  end if;\r\n\r\n  select count(*) into members\r\n  from public.couple_members cm\r\n  where cm.couple_id = target;\r\n\r\n  if members >= 2 then\r\n    raise exception 'Ce couple est complet';\r\n  end if;\r\n\r\n  insert into public.couple_members(user_id, couple_id)\r\n  values (uid, target);\r\n\r\n  return query select target as couple_id;\r\nend;\r\n$function$\n"
      },
      {
        "function_name": "search_v1_optimised",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select (string_to_array(name, ''/''))[level] as name\n           from storage.prefixes\n             where lower(prefixes.name) like lower($2 || $3) || ''%''\n               and bucket_id = $4\n               and level = $1\n           order by name ' || v_sort_order || '\n     )\n     (select name,\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[level] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where lower(objects.name) like lower($2 || $3) || ''%''\n       and bucket_id = $4\n       and level = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
      },
      {
        "function_name": "search_legacy_v1",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
      },
      {
        "function_name": "search",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    can_bypass_rls BOOLEAN;\nbegin\n    SELECT rolbypassrls\n    INTO can_bypass_rls\n    FROM pg_roles\n    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);\n\n    IF can_bypass_rls THEN\n        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    ELSE\n        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    END IF;\nend;\n$function$\n"
      },
      {
        "function_name": "get_size_by_bucket",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::bigint) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
      },
      {
        "function_name": "objects_update_prefix_trigger",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    old_prefixes TEXT[];\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Retrieve old prefixes\n        old_prefixes := \"storage\".\"get_prefixes\"(OLD.\"name\");\n\n        -- Remove old prefixes that are only used by this object\n        WITH all_prefixes as (\n            SELECT unnest(old_prefixes) as prefix\n        ),\n        can_delete_prefixes as (\n             SELECT prefix\n             FROM all_prefixes\n             WHERE NOT EXISTS (\n                 SELECT 1 FROM \"storage\".\"objects\"\n                 WHERE \"bucket_id\" = OLD.\"bucket_id\"\n                   AND \"name\" <> OLD.\"name\"\n                   AND \"name\" LIKE (prefix || '%')\n             )\n         )\n        DELETE FROM \"storage\".\"prefixes\" WHERE name IN (SELECT prefix FROM can_delete_prefixes);\n\n        -- Add new prefixes\n        PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    END IF;\n    -- Set the new level\n    NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
      },
      {
        "function_name": "enforce_bucket_name_length",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n    if length(new.name) > 100 then\n        raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);\n    end if;\n    return new;\nend;\n$function$\n"
      },
      {
        "function_name": "search_v2",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n    sort_col text;\n    sort_ord text;\n    cursor_op text;\n    cursor_expr text;\n    sort_expr text;\nBEGIN\n    -- Validate sort_order\n    sort_ord := lower(sort_order);\n    IF sort_ord NOT IN ('asc', 'desc') THEN\n        sort_ord := 'asc';\n    END IF;\n\n    -- Determine cursor comparison operator\n    IF sort_ord = 'asc' THEN\n        cursor_op := '>';\n    ELSE\n        cursor_op := '<';\n    END IF;\n    \n    sort_col := lower(sort_column);\n    -- Validate sort column  \n    IF sort_col IN ('updated_at', 'created_at') THEN\n        cursor_expr := format(\n            '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE \"C\") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',\n            sort_col, cursor_op\n        );\n        sort_expr := format(\n            'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE \"C\" %s',\n            sort_col, sort_ord, sort_ord\n        );\n    ELSE\n        cursor_expr := format('($5 = '''' OR name COLLATE \"C\" %s $5)', cursor_op);\n        sort_expr := format('name COLLATE \"C\" %s', sort_ord);\n    END IF;\n\n    RETURN QUERY EXECUTE format(\n        $sql$\n        SELECT * FROM (\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name,\n                    NULL::uuid AS id,\n                    updated_at,\n                    created_at,\n                    NULL::timestamptz AS last_accessed_at,\n                    NULL::jsonb AS metadata\n                FROM storage.prefixes\n                WHERE name COLLATE \"C\" LIKE $1 || '%%'\n                    AND bucket_id = $2\n                    AND level = $4\n                    AND %s\n                ORDER BY %s\n                LIMIT $3\n            )\n            UNION ALL\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name,\n                    id,\n                    updated_at,\n                    created_at,\n                    last_accessed_at,\n                    metadata\n                FROM storage.objects\n                WHERE name COLLATE \"C\" LIKE $1 || '%%'\n                    AND bucket_id = $2\n                    AND level = $4\n                    AND %s\n                ORDER BY %s\n                LIMIT $3\n            )\n        ) obj\n        ORDER BY %s\n        LIMIT $3\n        $sql$,\n        cursor_expr,    -- prefixes WHERE\n        sort_expr,      -- prefixes ORDER BY\n        cursor_expr,    -- objects WHERE\n        sort_expr,      -- objects ORDER BY\n        sort_expr       -- final ORDER BY\n    )\n    USING prefix, bucket_name, limits, levels, start_after, sort_column_after;\nEND;\n$function$\n"
      },
      {
        "function_name": "lock_top_prefixes",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket text;\n    v_top text;\nBEGIN\n    FOR v_bucket, v_top IN\n        SELECT DISTINCT t.bucket_id,\n            split_part(t.name, '/', 1) AS top\n        FROM unnest(bucket_ids, names) AS t(bucket_id, name)\n        WHERE t.name <> ''\n        ORDER BY 1, 2\n        LOOP\n            PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));\n        END LOOP;\nEND;\n$function$\n"
      },
      {
        "function_name": "check_couple_members_limit",
        "schema_name": "public",
        "definition": "CREATE OR REPLACE FUNCTION public.check_couple_members_limit()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  if (select count(*) from couple_members where couple_id = new.couple_id) >= 2 then\r\n    raise exception 'Ce couple est dÃ©jÃ  complet (maximum 2 membres)';\r\n  end if;\r\n  return new;\r\nend;\r\n$function$\n"
      },
      {
        "function_name": "objects_delete_cleanup",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_delete_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket_ids text[];\n    v_names      text[];\nBEGIN\n    IF current_setting('storage.gc.prefixes', true) = '1' THEN\n        RETURN NULL;\n    END IF;\n\n    PERFORM set_config('storage.gc.prefixes', '1', true);\n\n    SELECT COALESCE(array_agg(d.bucket_id), '{}'),\n           COALESCE(array_agg(d.name), '{}')\n    INTO v_bucket_ids, v_names\n    FROM deleted AS d\n    WHERE d.name <> '';\n\n    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);\n    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);\n\n    RETURN NULL;\nEND;\n$function$\n"
      },
      {
        "function_name": "objects_update_cleanup",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    -- NEW - OLD (destinations to create prefixes for)\n    v_add_bucket_ids text[];\n    v_add_names      text[];\n\n    -- OLD - NEW (sources to prune)\n    v_src_bucket_ids text[];\n    v_src_names      text[];\nBEGIN\n    IF TG_OP <> 'UPDATE' THEN\n        RETURN NULL;\n    END IF;\n\n    -- 1) Compute NEWâˆ’OLD (added paths) and OLDâˆ’NEW (moved-away paths)\n    WITH added AS (\n        SELECT n.bucket_id, n.name\n        FROM new_rows n\n        WHERE n.name <> '' AND position('/' in n.name) > 0\n        EXCEPT\n        SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> ''\n    ),\n    moved AS (\n         SELECT o.bucket_id, o.name\n         FROM old_rows o\n         WHERE o.name <> ''\n         EXCEPT\n         SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> ''\n    )\n    SELECT\n        -- arrays for ADDED (dest) in stable order\n        COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),\n        COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),\n        -- arrays for MOVED (src) in stable order\n        COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),\n        COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' )\n    INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;\n\n    -- Nothing to do?\n    IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN\n        RETURN NULL;\n    END IF;\n\n    -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks\n    DECLARE\n        v_all_bucket_ids text[];\n        v_all_names text[];\n    BEGIN\n        -- Combine source and destination arrays for consistent lock ordering\n        v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');\n        v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');\n\n        -- Single lock call ensures consistent global ordering across all transactions\n        IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN\n            PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);\n        END IF;\n    END;\n\n    -- 3) Create destination prefixes (NEWâˆ’OLD) BEFORE pruning sources\n    IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN\n        WITH candidates AS (\n            SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name\n            FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name)\n            WHERE name <> ''\n        )\n        INSERT INTO storage.prefixes (bucket_id, name)\n        SELECT c.bucket_id, c.name\n        FROM candidates c\n        ON CONFLICT DO NOTHING;\n    END IF;\n\n    -- 4) Prune source prefixes bottom-up for OLDâˆ’NEW\n    IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN\n        -- re-entrancy guard so DELETE on prefixes won't recurse\n        IF current_setting('storage.gc.prefixes', true) <> '1' THEN\n            PERFORM set_config('storage.gc.prefixes', '1', true);\n        END IF;\n\n        PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n"
      },
      {
        "function_name": "prefixes_delete_cleanup",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.prefixes_delete_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket_ids text[];\n    v_names      text[];\nBEGIN\n    IF current_setting('storage.gc.prefixes', true) = '1' THEN\n        RETURN NULL;\n    END IF;\n\n    PERFORM set_config('storage.gc.prefixes', '1', true);\n\n    SELECT COALESCE(array_agg(d.bucket_id), '{}'),\n           COALESCE(array_agg(d.name), '{}')\n    INTO v_bucket_ids, v_names\n    FROM deleted AS d\n    WHERE d.name <> '';\n\n    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);\n    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);\n\n    RETURN NULL;\nEND;\n$function$\n"
      },
      {
        "function_name": "objects_update_level_trigger",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_level_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Set the new level\n        NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
      },
      {
        "function_name": "delete_leaf_prefixes",
        "schema_name": "storage",
        "definition": "CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_rows_deleted integer;\nBEGIN\n    LOOP\n        WITH candidates AS (\n            SELECT DISTINCT\n                t.bucket_id,\n                unnest(storage.get_prefixes(t.name)) AS name\n            FROM unnest(bucket_ids, names) AS t(bucket_id, name)\n        ),\n        uniq AS (\n             SELECT\n                 bucket_id,\n                 name,\n                 storage.get_level(name) AS level\n             FROM candidates\n             WHERE name <> ''\n             GROUP BY bucket_id, name\n        ),\n        leaf AS (\n             SELECT\n                 p.bucket_id,\n                 p.name,\n                 p.level\n             FROM storage.prefixes AS p\n                  JOIN uniq AS u\n                       ON u.bucket_id = p.bucket_id\n                           AND u.name = p.name\n                           AND u.level = p.level\n             WHERE NOT EXISTS (\n                 SELECT 1\n                 FROM storage.objects AS o\n                 WHERE o.bucket_id = p.bucket_id\n                   AND o.level = p.level + 1\n                   AND o.name COLLATE \"C\" LIKE p.name || '/%'\n             )\n             AND NOT EXISTS (\n                 SELECT 1\n                 FROM storage.prefixes AS c\n                 WHERE c.bucket_id = p.bucket_id\n                   AND c.level = p.level + 1\n                   AND c.name COLLATE \"C\" LIKE p.name || '/%'\n             )\n        )\n        DELETE\n        FROM storage.prefixes AS p\n            USING leaf AS l\n        WHERE p.bucket_id = l.bucket_id\n          AND p.name = l.name\n          AND p.level = l.level;\n\n        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;\n        EXIT WHEN v_rows_deleted = 0;\n    END LOOP;\nEND;\n$function$\n"
      },
      {
        "function_name": "gen_join_code",
        "schema_name": "public",
        "definition": "CREATE OR REPLACE FUNCTION public.gen_join_code()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  code text;\r\nbegin\r\n  loop\r\n    -- code court, lisible, 6 chars\r\n    code := upper(substr(md5(gen_random_uuid()::text), 1, 6));\r\n    exit when not exists (select 1 from public.couples where join_code = code);\r\n  end loop;\r\n  return code;\r\nend;\r\n$function$\n"
      },
      {
        "function_name": "enforce_max_two_members",
        "schema_name": "public",
        "definition": "CREATE OR REPLACE FUNCTION public.enforce_max_two_members()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\ndeclare cnt int;\r\nbegin\r\n  select count(*) into cnt\r\n  from public.couple_members cm\r\n  where cm.couple_id = NEW.couple_id;\r\n\r\n  if cnt >= 2 then\r\n    raise exception 'Ce couple a dÃ©jÃ  2 membres';\r\n  end if;\r\n\r\n  return NEW;\r\nend;\r\n$function$\n"
      }
    ]
  }
]








Triggers :
[
  {
    "triggers_json": [
      {
        "trigger_name": "trg_max_two_members",
        "table_name": "couple_members",
        "definition": "CREATE TRIGGER trg_max_two_members BEFORE INSERT ON public.couple_members FOR EACH ROW EXECUTE FUNCTION enforce_max_two_members()"
      }
    ]
  }
]







Views:
[
  {
    "views_json": [
      {
        "view_name": "my_couple_status",
        "schema_name": "public",
        "definition": " SELECT cm.user_id,\n    c.id AS couple_id,\n    c.join_code,\n    c.started_at,\n    ( SELECT count(*) AS count\n           FROM couple_members cm2\n          WHERE (cm2.couple_id = c.id)) AS members_count\n   FROM (couple_members cm\n     JOIN couples c ON ((c.id = cm.couple_id)));"
      }
    ]
  }
]






Indexs:
[
  {
    "indexes_json": [
      {
        "index_name": "profiles_pkey",
        "table_name": "profiles",
        "definition": "CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id)"
      },
      {
        "index_name": "buckets_pkey",
        "table_name": "buckets",
        "definition": "CREATE UNIQUE INDEX buckets_pkey ON public.buckets USING btree (id)"
      },
      {
        "index_name": "bucket_items_pkey",
        "table_name": "bucket_items",
        "definition": "CREATE UNIQUE INDEX bucket_items_pkey ON public.bucket_items USING btree (id)"
      },
      {
        "index_name": "couples_pkey",
        "table_name": "couples",
        "definition": "CREATE UNIQUE INDEX couples_pkey ON public.couples USING btree (id)"
      },
      {
        "index_name": "couples_join_code_key",
        "table_name": "couples",
        "definition": "CREATE UNIQUE INDEX couples_join_code_key ON public.couples USING btree (join_code)"
      },
      {
        "index_name": "couple_members_pkey",
        "table_name": "couple_members",
        "definition": "CREATE UNIQUE INDEX couple_members_pkey ON public.couple_members USING btree (user_id)"
      },
      {
        "index_name": "couple_members_user_id_idx",
        "table_name": "couple_members",
        "definition": "CREATE UNIQUE INDEX couple_members_user_id_idx ON public.couple_members USING btree (user_id)"
      },
      {
        "index_name": "couple_events_pkey",
        "table_name": "couple_events",
        "definition": "CREATE UNIQUE INDEX couple_events_pkey ON public.couple_events USING btree (id)"
      },
      {
        "index_name": "idx_couple_events_couple_starts_at",
        "table_name": "couple_events",
        "definition": "CREATE INDEX idx_couple_events_couple_starts_at ON public.couple_events USING btree (couple_id, starts_at)"
      },
      {
        "index_name": "idx_events_couple",
        "table_name": "couple_events",
        "definition": "CREATE INDEX idx_events_couple ON public.couple_events USING btree (couple_id, starts_at)"
      },
      {
        "index_name": "note_reactions_pkey",
        "table_name": "note_reactions",
        "definition": "CREATE UNIQUE INDEX note_reactions_pkey ON public.note_reactions USING btree (id)"
      },
      {
        "index_name": "idx_note_reactions_note_user",
        "table_name": "note_reactions",
        "definition": "CREATE UNIQUE INDEX idx_note_reactions_note_user ON public.note_reactions USING btree (note_id, user_id)"
      },
      {
        "index_name": "idx_note_reactions_note_id",
        "table_name": "note_reactions",
        "definition": "CREATE INDEX idx_note_reactions_note_id ON public.note_reactions USING btree (note_id)"
      },
      {
        "index_name": "idx_love_notes_couple_created_at",
        "table_name": "love_notes",
        "definition": "CREATE INDEX idx_love_notes_couple_created_at ON public.love_notes USING btree (couple_id, created_at DESC)"
      },
      {
        "index_name": "love_notes_pkey",
        "table_name": "love_notes",
        "definition": "CREATE UNIQUE INDEX love_notes_pkey ON public.love_notes USING btree (id)"
      },
      {
        "index_name": "idx_notes_couple",
        "table_name": "love_notes",
        "definition": "CREATE INDEX idx_notes_couple ON public.love_notes USING btree (couple_id, created_at DESC)"
      },
      {
        "index_name": "albums_pkey",
        "table_name": "albums",
        "definition": "CREATE UNIQUE INDEX albums_pkey ON public.albums USING btree (id)"
      },
      {
        "index_name": "albums_couple_id_idx",
        "table_name": "albums",
        "definition": "CREATE INDEX albums_couple_id_idx ON public.albums USING btree (couple_id)"
      },
      {
        "index_name": "albums_is_private_idx",
        "table_name": "albums",
        "definition": "CREATE INDEX albums_is_private_idx ON public.albums USING btree (is_private)"
      },
      {
        "index_name": "photos_pkey",
        "table_name": "photos",
        "definition": "CREATE UNIQUE INDEX photos_pkey ON public.photos USING btree (id)"
      },
      {
        "index_name": "photos_album_id_idx",
        "table_name": "photos",
        "definition": "CREATE INDEX photos_album_id_idx ON public.photos USING btree (album_id)"
      },
      {
        "index_name": "photos_couple_id_idx",
        "table_name": "photos",
        "definition": "CREATE INDEX photos_couple_id_idx ON public.photos USING btree (couple_id)"
      },
      {
        "index_name": "photos_location_idx",
        "table_name": "photos",
        "definition": "CREATE INDEX photos_location_idx ON public.photos USING btree (latitude, longitude) WHERE ((latitude IS NOT NULL) AND (longitude IS NOT NULL))"
      },
      {
        "index_name": "user_prefs_pkey",
        "table_name": "user_prefs",
        "definition": "CREATE UNIQUE INDEX user_prefs_pkey ON public.user_prefs USING btree (user_id)"
      }
    ]
  }
]
